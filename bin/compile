#!/usr/bin/env bash

# bin/compile <build-dir> <cache-dir> <env-dir>

# fail hard
set -o pipefail
# fail harder
set -eu
# move hidden files too, just in case
shopt -s dotglob

# some basic config vars we never want to export
ignore_config_vars=("IFS" "HOME" "PATH" "CPATH" "CPPATH" "LD_PRELOAD" "LIBRARY_PATH" "LD_LIBRARY_PATH" "STACK" "REQUEST_ID" "HEROKU_PHP_INSTALL_DEV" "OLDPWD" "PWD" "DYNO")

STACK=${STACK:-heroku-22} # Anvil has none
build_dir=$1
cache_dir=$2
php_cache_dir="$cache_dir/php"
mkdir -p "$php_cache_dir"
env_dir=${3:-} # Anvil has none
bp_dir=$(cd $(dirname $0); cd ..; pwd)

# Initialise the build report data store. We do this first to ensure the data store from the previous
# build is still reset if the build fails due to an internal error when importing other modules.
source "$bp_dir/bin/util/build_report.sh"
build_report::setup

build_report::start_timer __main__

# TODO: Remove these and the mcount/... utils in common.sh once all consumers are converted to `build_report::*`.
export BPLOG_PREFIX="buildpack.php"
export BUILDPACK_LOG_FILE=${BUILDPACK_LOG_FILE:-/dev/null}
ignore_config_vars+=("BPLOG_PREFIX" "BUILDPACK_LOG_FILE")

# convenience functions
source $bp_dir/bin/util/common.sh

# use err_trap from common.sh on error to log and output a call stack
# we do not 'set -o errtrace', because that would cause subshell failures to fire the trap twice, e.g. with someval=$(func_that_fails)
trap 'err_trap' ERR

# use exit_trap from common.sh on exit to stop all open timers and, on non-zero exit, log a failure reason and call stack, if not already present
# (the second part acts as a "fallback" failure log mechanism for any explicit non-zero exit calls that do not log a reason/detail)
trap 'exit_trap' EXIT

# failure counting
source $bp_dir/bin/util/failures.sh

# for extensions that need special treatment
source $bp_dir/bin/util/newrelic.sh
source $bp_dir/bin/util/blackfire.sh

# if this is set it prevents Git clones (e.g. for Composer installs from source) during the build in some circumstances, and it is set in SSH Git deploys to Heroku
unset GIT_DIR
ignore_config_vars+=("GIT_DIR")

cd $build_dir

export_env_dir "$env_dir" '^COMPOSER$'
if [[ -n ${COMPOSER:-} ]]; then
	status "Using '$COMPOSER' (from "'$COMPOSER env var) for installation.'
else
	export COMPOSER="composer.json"
fi
export COMPOSER_LOCK=$(basename "$COMPOSER" ".json")".lock" # replace .json with .lock if it exists, append .lock otherwise
ignore_config_vars+=("COMPOSER_LOCK")

# we're using this error message in two places
composer_lock_parse_error=$(
	cat <<-EOF
		Failed to parse '$COMPOSER_LOCK'!

		There was an error parsing '$COMPOSER_LOCK'; it must be a valid
		file generated by Composer and be in an up-to-date state.

		Look above for any errors/warnings and address them if necessary.%s

		You most likely created or edited the file by hand, or a merge
		conflict was not resolved properly, resulting in a syntax error
		in the file. Refer to the docs for information on re-generating
		the lock file: https://getcomposer.org/doc/01-basic-usage.md

		Please perform the following steps locally on your computer to
		resolve this issue before attempting another deploy:
		1) Run 'composer update' to re-generate the lock file
		2) stage the lock file changes using 'git add $COMPOSER_LOCK'
		3) commit the change using 'git commit'

		You can run 'composer validate' locally on your computer for
		further diagnosis. Remember to also always keep your lock file
		up to date with any changes according to the instructions at
		https://getcomposer.org/doc/01-basic-usage.md

		Please remember to always keep your '$COMPOSER_LOCK' updated in
		lockstep with '$COMPOSER' to avoid common problems related
		to dependencies during collaboration and deployment.
	EOF
)

# a bunch of sanity checks first
if [[ -s "$COMPOSER" ]]; then
	composer_json_lint=$(python3 -mjson.tool "$COMPOSER" 2>&1 >/dev/null) || {
		build_report::set_string failure_reason composer_json.lint
		build_report::set_string failure_detail "$composer_json_lint"
		error <<-EOF
			Basic validation for '$COMPOSER' failed!
			
			It must be a valid JSON document compatible with Composer.
			
			You most likely created or edited the file by hand, and it now
			contains a syntax error. Please refer to the documentation at
			https://getcomposer.org/doc/ for information on the format.
			
			The following syntax error was reported:
			$(echo "${composer_json_lint}" | indent -i 2 -p "> ")
			
			You can run 'composer validate' locally on your computer for
			further diagnosis. Remember to also always keep your lock file
			up to date with any changes according to the instructions at
			https://getcomposer.org/doc/01-basic-usage.md
		EOF
	}
	if [[ ! -f "$COMPOSER_LOCK" ]]; then
		python3 -c 'import sys, json; sys.exit(bool(json.load(sys.stdin).get("require", {})))' 2>/dev/null < "$COMPOSER" || {
			build_report::set_string failure_reason composer_lock.missing
			error <<-EOF
				No '$COMPOSER_LOCK' found!
				
				A '$COMPOSER_LOCK' file was not found in your project, but there
				is a '$COMPOSER' file with dependencies inside 'require'.
				
				The lock file is required in order to guarantee reliable and
				reproducible installation of dependencies across platforms and
				deploys. You must follow the Composer best practice of having
				your lock file under version control in order to deploy. The
				lock file must not be in your '.gitignore'.
				
				Please perform the following steps locally on your computer to
				resolve this issue before attempting another deploy:
				1) remove '$COMPOSER_LOCK' from file '.gitignore', if present
				2) if no '$COMPOSER_LOCK' exists, run 'composer update'
				3) stage the lock file changes using 'git add $COMPOSER_LOCK'
				4) if you edited '.gitignore', also run 'git add .gitignore'
				5) commit the change using 'git commit'
				
				Please remember to always keep your '$COMPOSER_LOCK' updated in
				lockstep with '$COMPOSER' to avoid common problems related
				to dependencies during collaboration and deployment.
				
				Please refer to the Composer documentation for further details:
				https://getcomposer.org/doc/
				https://getcomposer.org/doc/01-basic-usage.md
			EOF
		}
	else
		composer_lock_lint=$(python3 -mjson.tool "$COMPOSER_LOCK" 2>&1 >/dev/null) || {
			build_report::set_string failure_reason composer_lock.lint
			build_report::set_string failure_detail "$composer_lock_lint"
			printf -v composer_lock_lint_message "\n\nThe following syntax error was reported:\n%s" "$(echo "${composer_lock_lint}" | indent -i 2 -p "> ")"
			error "$(printf "$composer_lock_parse_error" "$composer_lock_lint_message")"
		}
	fi
else
	if [[ ! -f "$COMPOSER" ]]; then
		mcount "warnings.composer_json.missing"
		warning <<-EOF
			No '$COMPOSER' found!
			
			Your project only contains an 'index.php', no '$COMPOSER'.
			
			Using 'index.php' to declare app type as PHP is deprecated and
			may lead to unexpected behavior.
			
			Please consider updating your codebase to utilize Composer and
			modern dependency management in order to benefit from the latest
			PHP runtimes and improved application performance, as well as
			control over the PHP versions and extensions available.
			
			For an introduction to dependency management with Composer and
			how to get the most out of PHP on Heroku, refer to the docs at
			https://getcomposer.org/doc/00-intro.md and
			https://devcenter.heroku.com/articles/getting-started-with-php
		EOF
	else
		mcount "warnings.composer_json.empty"
		notice <<-EOF
			Your '$COMPOSER' is completely empty!
			
			A completely empty file is not a valid JSON document.
			
			Heroku automatically corrected this problem, but it is strongly
			recommended you change the contents to at least '{}'.
			
			For documentation on Composer and dependency management, check
			out the introduction at https://getcomposer.org/doc/00-intro.md
		EOF
	fi
	echo "{}" > $COMPOSER
fi

# PHP expects to be installed in /app/.heroku/php because of compiled paths, let's set that up!
mkdir -p /app/.heroku
# other buildpacks use this magic directory, too
mkdir -p $build_dir/.heroku
# all our system packages live in there
mkdir $build_dir/.heroku/php || {
	# looks like platform packages are already there
	# this can happen if the buildpack is set twice, or if a user is trying to build an already built app
	# (e.g. by downloading a slug from Heroku and checking it into Git)
	build_report::set_string failure_reason slug_as_source
	error <<-EOF
		Your app source code contains artifacts from a previous build!
		
		A '.heroku/php/' directory exists in your app source, but this
		directory is created during a build of your app and should not
		be in your source repository, as it contains binaries for PHP,
		web servers, PHP extensions, and so forth.
		
		This situation can happen if you:
		1) have accidentally set this buildpack on your app twice;
		2) downloaded a built app ("slug") and used it as source code.
		
		To address situation 1, check the 'heroku buildpacks' command.
		
		To address situation 2, ensure the following directories are
		not part of your source code in your version control system:
		- .heroku/
		- .profile.d/
		- vendor/
		
		It is recommended you create a new Git repository that doesn't
		have these directories in its commit history. If you only
		perform a 'git rm', the binaries will remain part of your code
		repository, and inflate its size by hundreds of megabytes. You
		may also use common techniques for rewriting commit history to
		retroactively remove the directories from the old commits that
		introduced them.
		
		If you were using other buildpacks together with PHP, you may
		want to ensure that those buildpacks' build artifacts, such as
		a Node.js 'node_modules/' directory, are also not part of your
		source code repository.
	EOF
}
# set up Composer
export COMPOSER_HOME=$php_cache_dir/.composer
# $COMPOSER_HOME/cache is the default, but we want to be explicit
export COMPOSER_CACHE_DIR=$COMPOSER_HOME/cache
mkdir -p $COMPOSER_CACHE_DIR
export COMPOSER_NO_INTERACTION=1
ignore_config_vars+=("COMPOSER_(CACHE_DIR|HOME|NO_INTERACTION)")

# if the build dir is not "/app", we symlink in the .heroku/php subdir (and only that, to avoid problems with other buildpacks) so that PHP correctly finds its INI files etc
[[ $build_dir == '/app' ]] || ln -s $build_dir/.heroku/php /app/.heroku/php

build_report::start_timer bootstrap

status "Bootstrapping..."

if [[ $STACK == "heroku-22" ]]; then
	stack_locator=$STACK
else
	stack_locator="${STACK}-$(dpkg --print-architecture)"
fi
s3_url="https://lang-php.s3.us-east-1.amazonaws.com/dist-${stack_locator}-stable/"
# hash the list of "declared" build formulae, this is the "snapshot" of a fixed repo state
platform_repo_url="${s3_url}packages-$("$bp_dir"/support/build/_util/formulae-hash.sh).json"
if ! curl_retry_on_18  --retry-connrefused --retry 3 --connect-timeout 10 --fail --silent -I "$platform_repo_url" > /dev/null; then
	notice_inline "Default platform repository snapshot not available."
	export_env_dir "$env_dir" '^HEROKU_PHP_PLATFORM_REPOSITORY_SNAPSHOT_FALLBACK$'
	# let's check if a fallback to the non-snapshot URL is allowed
	if [[ "${HEROKU_PHP_PLATFORM_REPOSITORY_SNAPSHOT_FALLBACK:-0}" != "0" ]]; then
		notice_inline 'Falling back to latest repository version as allowed by $HEROKU_PHP_PLATFORM_REPOSITORY_SNAPSHOT_FALLBACK.'
		platform_repo_url=$s3_url
	fi
	# if no fallback is allowed, we do nothing - it is possible that $HEROKU_PHP_PLATFORM_REPOSITORIES removes the default repo
fi

# prepend the default repo to the list configured by the user
# list of repositories to use is in ascening order of precedence
export_env_dir "$env_dir" '^HEROKU_PHP_PLATFORM_REPOSITORIES$'
have_custom_platform_repos="${HEROKU_PHP_PLATFORM_REPOSITORIES:+1}"
HEROKU_PHP_PLATFORM_REPOSITORIES="${platform_repo_url} ${HEROKU_PHP_PLATFORM_REPOSITORIES:-}"
if [[ "${HEROKU_PHP_PLATFORM_REPOSITORIES}" == *" - "* ]]; then
	# a single "-" in the user supplied string removes everything to the left of it; can be used to delete the default repo
	notice_inline "Default platform repository disabled."
	HEROKU_PHP_PLATFORM_REPOSITORIES=${HEROKU_PHP_PLATFORM_REPOSITORIES#*" - "}
	s3_url=$(echo "$HEROKU_PHP_PLATFORM_REPOSITORIES" | cut -f1 -d" " | sed 's/[^/]*$//')
	notice_inline 'Bootstrapping using first repository in $HEROKU_PHP_PLATFORM_REPOSITORIES.'
fi


# minimal PHP needed for installs, and make "composer" invocations use that for now
mkdir -p $build_dir/.heroku/php-min
ln -s $build_dir/.heroku/php-min /app/.heroku/php-min

curl_retry_on_18 --retry-connrefused --retry 3 --connect-timeout 10 --fail --silent --location -o $build_dir/.heroku/php-min.tar.gz "${s3_url}php-min-8.3.27.tar.gz" || {
	build_report::set_string failure_reason bootstrap.download
	build_report::set_string failure_detail php-min
	error <<-EOF
		Failed to download minimal PHP for bootstrapping!
		
		This is most likely a temporary internal error. If the problem
		persists, make sure that you are not running a custom or forked
		version of the Heroku PHP buildpack which may need updating.
	EOF
}
tar xzf $build_dir/.heroku/php-min.tar.gz -C $build_dir/.heroku/php-min
rm $build_dir/.heroku/php-min.tar.gz

curl_retry_on_18 --retry-connrefused --retry 3 --connect-timeout 10 --fail --silent --location -o $build_dir/.heroku/composer.tar.gz "${s3_url}composer-2.8.12.tar.gz" || {
	build_report::set_string failure_reason bootstrap.download
	build_report::set_string failure_detail composer
	error <<-EOF
		Failed to download Composer for bootstrapping!
		
		This is most likely a temporary internal error. If this problem
		persists, make sure that you are not running a custom or forked
		version of the Heroku PHP buildpack which may need updating.
	EOF
}
tar xzf $build_dir/.heroku/composer.tar.gz -C $build_dir/.heroku/php-min bin/composer
rm $build_dir/.heroku/composer.tar.gz

# this alias function is for installing platform packages
# it passes the expected env vars for the installer plugin,
# and executes the bootstrapped composer using the bootstrapped minimal php
# (with the platform installation dir of .heroku/php/ as the cwd)
platform-composer() {
	# we use env -i to ensure a clean environment with only the vars we want
	# some are forwarded (like PATH or COMPOSER_HOME)
	# some are static
	# some are forwarded only if they exist (like PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO)
	# -- n.b. the quoted string in the unquoted "+" parameter expansion ensures that nothing (and not an empty string) is passed if absent
	# -- n.b. can't use the "@A" parameter expansion since that would produce "declare -x ..." for exported vars, and "@Q" would double-quote
	# export_file_path and profile_dir_path will be used by the installer plugin
	# they are also used in later install attempts for add-on extensions (blackfire, newrelic, ...)
	# providedextensionslog_file_path is only passed during the main platform install step
	# the PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_INDENT value does nothing without PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO
	# we will leave passing that variable up to the caller for now
	# NO_COLOR=1 suppresses the download progress meter whose ANSI cursor codes trip up output in Heroku Dashboard
	env -i \
	PATH="$PATH" \
	COMPOSER_NO_INTERACTION=1 \
	COMPOSER_HOME="${COMPOSER_HOME}" \
	COMPOSER_CACHE_DIR="${COMPOSER_CACHE_DIR}" \
	export_file_path="${bp_dir}/export" \
	profile_dir_path="${build_dir}/.profile.d" \
	${providedextensionslog_file_path:+"providedextensionslog_file_path=${providedextensionslog_file_path}"} \
	${PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO:+"PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO=${PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO}"} \
	PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_INDENT="${PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_INDENT:-7}" \
	NO_COLOR=1 \
	/app/.heroku/php-min/bin/php /app/.heroku/php-min/bin/composer -d "${build_dir}/.heroku/php" "$@"
}
export -f platform-composer

build_report::stop_timer bootstrap

mkdir -p $build_dir/.profile.d

# we perform this check early so people with stale lock files are reminded why if their lock file errors in the next step
composer_lock_outdated=false
platform-composer validate --no-plugins --no-check-publish --no-check-all --quiet "$(realpath "$COMPOSER")" 2>/dev/null || {
	mcount "warnings.composer_lock.outdated"
	composer_lock_outdated=true
	warning <<-EOF
		Your '$COMPOSER_LOCK' is out of date!
		
		The '$COMPOSER_LOCK' file in your project is not up to date with
		the main '$COMPOSER' file. This may result in installation
		of incorrect packages or package versions.
		
		The lock file is required in order to guarantee reliable and
		reproducible installation of dependencies across systems and
		deploys. It must always be kept in sync with '$COMPOSER'.
		
		Whenever you change '$COMPOSER', ensure that you perform
		the following steps locally on your computer:
		1) run 'composer update'
		2) add all changes using 'git add $COMPOSER $COMPOSER_LOCK'
		3) commit using 'git commit'
		
		Ensure that you updated the lock file correctly, and that you
		ran 'git add' on both files, before deploying again.
		
		Please remember to always keep your '$COMPOSER_LOCK' updated in
		lockstep with '$COMPOSER' to avoid common problems related
		to dependencies during collaboration and deployment.
		
		Please refer to the Composer documentation for further details:
		https://getcomposer.org/doc/
		https://getcomposer.org/doc/01-basic-usage.md
	EOF
}

# if prefer-stable is false and minimum-stability is not stable, warn about potential unstable platform installs
[[ ! -f "$COMPOSER_LOCK" ]] || minimum_stability=$(cat "$COMPOSER_LOCK" | python3 -c 'import sys, json; l = json.load(sys.stdin); print(l.get("minimum-stability")); sys.exit(l.get("minimum-stability", "stable") != "stable" and l.get("prefer-stable", False) == False);' 2> /dev/null) || {
	possible_stabilities="dev, alpha, beta, or RC"
	case $minimum_stability in
		alpha)
			possible_stabilities="alpha, beta, or RC"
			;;
		beta)
			possible_stabilities="beta or RC"
			;;
		[rR][cC])
			possible_stabilities="release candidate"
			;;
	esac
	mcount "warnings.composer_lock.minimum_stability"
	warning <<-EOF
		Non-stable 'minimum-stability'!
	
		Your '$COMPOSER' contains a 'minimum-stability' setting of
		'$minimum_stability', and the 'prefer-stable' setting is not enabled.
		
		This combination of options may negatively impact the stability
		of your app and result in crashes as it permits installation of
		$possible_stabilities versions of PHP runtimes and extensions.
		
		If possible, you should always use explicit stability flags on
		only those dependencies that you want unstable versions of, and
		leave 'minimum-stability' at its default 'stable' setting.
		
		If you really need a global 'minimum-stability' setting lower
		than 'stable', it is strongly recommended that you enable the
		'prefer-stable' setting in '$COMPOSER'.
		
		For more information, refer to the following documentation:
		https://getcomposer.org/doc/articles/versions.md
		https://getcomposer.org/doc/04-schema.md#package-links
		https://getcomposer.org/doc/04-schema.md#minimum-stability
		https://getcomposer.org/doc/04-schema.md#prefer-stable
	EOF
}

build_report::start_timer platform.prepare

status "Preparing platform package installation..."

HEROKU_PHP_DEFAULT_RUNTIME_VERSION="^8.1.0 <8.5"
export HEROKU_PHP_DEFAULT_RUNTIME_VERSION
# extract requirements from composer.lock
{ platform_stderr=$(/app/.heroku/php-min/bin/php $bp_dir/bin/util/platform.php ${have_custom_platform_repos:+"--list-repositories"} "$bp_dir/support/installer/" $HEROKU_PHP_PLATFORM_REPOSITORIES 2>&1 >$build_dir/.heroku/php/composer.json | tee >(indent > /dev/stderr)); } || {
	code=$?
	if (( code == 3 )); then
		build_report::set_string failure_reason platform.prepare.runtime_only_in_dev
		build_report::set_string failure_detail "$platform_stderr"
		error <<-EOF
			Runtime specified in 'require-dev' but not in 'require'!
			
			Your '$COMPOSER' contains a 'require-dev' section which
			specifies a PHP runtime version (either directly, or through
			a dependency), but no such requirement is present in 'require'
			or in any of the packages listed in 'require'.
			
			Even if dev requirements are not being installed, the entirety
			of all dependencies needs to resolve to an installable set.
			Heroku cannot select a default runtime version in this case.
			
			Please perform the following steps locally on your computer to
			resolve this issue before attempting another deploy:
			1) add a dependency for 'php' to 'require' in '$COMPOSER'
			2) run 'composer update' to re-generate the lock file
			3) stage changes using 'git add $COMPOSER $COMPOSER_LOCK'
			4) commit changes using 'git commit'
			
			For more information on selecting PHP runtimes, please refer to
			https://devcenter.heroku.com/articles/php-support
		EOF
	elif (( code == 4 )); then
		build_report::set_string failure_reason platform.repositories.url_invalid
		build_report::set_string failure_detail "$platform_stderr"
		error 'Invalid $HEROKU_PHP_PLATFORM_REPOSITORIES value'
	else
		build_report::set_string failure_reason composer_lock.parse
		build_report::set_string failure_detail "$platform_stderr"
		error "$(printf "$composer_lock_parse_error" "")" # printf placeholder not used here
	fi
}

build_report::stop_timer platform.prepare

build_report::start_timer platform.install

status "Installing platform packages..."

build_report::start_timer platform.install.main

# providedextensionslog_file_path is used to record packages that provide native extensions for this one install step only
export providedextensionslog_file_path=$(mktemp -t "provided-extensions.log.XXXXXX" -u)
# we make a new file descriptor for the installer plugin to log "human readable" display output to, duplicated to stdout
exec {PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO}>&1
# the installer picks up the FD number in this env var, and writes a "display output" log to it
# meanwhile, the "raw" output of 'composer install' goes to install.log in case we need it later
export PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO
if platform-composer install ${HEROKU_PHP_INSTALL_DEV-"--no-dev"} > $build_dir/.heroku/php/install.log 2>&1; then
	:
else
	code=$?
	install_log=$(
		sed -E \
			-e 's/heroku-sys\///g' \
			-e 's/^Loading composer repositories with package information/Loading repositories with available runtimes and extensions/' \
			-e 's/^Installing dependencies.*//' \
			-e '/^No composer\.lock file present/d' \
			-e '/^Potential causes:/,$d' \
			-e "\#satisfiable by ${COMPOSER}/${COMPOSER_LOCK}#d" \
			-e "s#(${COMPOSER}/${COMPOSER_LOCK}) dev-[0-9a-f]+#\1#" \
			"$build_dir/.heroku/php/install.log"
	)
	if [[ $code -eq 2 ]]; then
		# dependency solving failed
		mcount "failures.platform.solving.$(detect_platform_solving_failures <<< "$install_log")"
		build_report::set_string failure_reason platform.install.main.solving
		build_report::set_string failure_detail "$(sed -e '1,/Your requirements could not be resolved to an installable set of packages/d' -e '/^\s*$/d' <<< "$install_log")"
	else
		# something else
		mcount "failures.platform.install.$(detect_platform_install_failures <<< "$install_log")"
		build_report::set_string failure_reason platform.install.main.install
		build_report::set_string failure_detail "${install_log:0:1000}"
	fi
	
	error <<-EOF
		Failed to install system packages!
		
		Your platform requirements (for runtimes and extensions) could
		not be resolved to an installable set of dependencies, or a
		platform package repository was unreachable.
		
		This usually means that you (or packages you are using) depend
		on a combination of PHP versions and/or extensions that are
		currently not available on Heroku.
		
		The following is the full output from the installation attempt:
		
		$(echo "$install_log" | indent -i 2 -p ">")
		$(
			# via sed, make every line yellow at the start and re-set to red at the end
			$composer_lock_outdated && cat <<-EOF2 | sed -e $'s/^/\033[1;33m/' -e $'s/$/\033[1;31m/'
				
				A possible cause for this error is your '$COMPOSER_LOCK' file,
				which is currently out of date, as changes have been made to
				your '$COMPOSER' that are not yet reflected in the lock file.
				
				In order to guarantee reliable installation of system packages,
				Heroku uses information from '$COMPOSER_LOCK'.
				
				If you already attempted to fix the error above by updating the
				requirements in '$COMPOSER', remember to also update the
				lock file by running 'composer update', followed by a 'git add'
				and 'git commit' of the changes. The warning message further
				above contains step-by-step instructions.
				
				Please remember to always keep your '$COMPOSER_LOCK' updated in
				lockstep with '$COMPOSER' to avoid common problems related
				to dependencies during collaboration and deployment.
				
			EOF2
		)
		For reference, the following runtimes are currently available:
		
		PHP: $(
			platform-composer show -f json --available heroku-sys/php |
			jq -r '.versions | join(", ")' |
			fold -b -s -w 59 | # 59 characters at a time, wrap on whitespace
			indent -i5 --no-first-line-indent || true # indent all lines except first to line up with "PHP: "
		)
		
		Please verify that all requirements for runtime versions in
		'$COMPOSER_LOCK' are compatible with the list above, and ensure
		all required extensions are available for the desired runtimes.
		
		When choosing a PHP runtimes and extensions, please also ensure
		they are available on your app's stack ($STACK), and select
		a different stack if needed after consulting the article below.
		
		For a list of supported runtimes & extensions on Heroku, please
		refer to: https://devcenter.heroku.com/articles/php-support
	EOF
fi

# log number of platform packages installed based on the packages and requirements we assembled
# this includes composer and web servers, but may not include extensions skipped due to the presence of polyfill packages
# if there are no packages, 'composer show -f json' returns an empty array instead of an object with empty "installed" key
platform_packages_installed_count=$(platform-composer show -f json "heroku-sys/*" | jq -r '.installed? // {} | length' || printf -- "-1")
build_report::set_raw platform.install.main.packages.installed_count "$platform_packages_installed_count"

build_report::stop_timer platform.install.main

export -n providedextensionslog_file_path # export no longer needed (and we don't want more entries written by the plugin even if it encounters them)
declare -i polyfill_count=0
if [[ -s "$providedextensionslog_file_path" ]]; then
	build_report::start_timer platform.install.polyfill_replacement
	declare -i polyfill_replacement_attempted_count=0
	declare -i polyfill_replacement_succeeded_count=0
	declare -a polyfill_replacement_unavailable=()
	notice_inline "detected userland polyfill packages for PHP extensions"
	notice_inline "now attempting to install native extension packages"
	# the platform installer recorded userland packages that "provide" a PHP extension
	# for each occurrence (source package providing other package(s)) in the list,
	# we will now attempt to install the real native extension packages (rest of the line)
	# this isolated install will not change anything else about the existing dependency graph
	while read -r -u "$fd_num" line; do # $fd_num comes from the end of the loop
		(( ++polyfill_count ))
		read -r -a provides <<< "$line" # read words of line into array
		echo "- Installing extensions provided by ${provides[0]}..." | indent # first "word" is userland package name
		for extension in "${provides[@]:1}"; do # remaining words in line are native extensions it declares "provide"d
			(( ++polyfill_replacement_attempted_count ))
			ext_package=$(cut -d":" -f1 <<< "$extension") # extract name from "ext-foo:1.2.3" string
			ext_name=${ext_package#"heroku-sys/"} # no "heroku-sys/" prefix for human output
			# run a `composer require`, confined to the package we're attempting, allowing any version
			#   (the .native "replace"d variant in each extension matches the regular version, so the constraint for that regular version is enough)
			if ! PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_INDENT=9 platform-composer require "${ext_package}.native:*" >> $build_dir/.heroku/php/install.log 2>&1; then
				polyfill_replacement_unavailable+=("$ext_name")
				# composer did not succeed; this means no package that matches all existing package's requirements was found
				notice_inline -i9 "no suitable native version of ${ext_name} available"
			else
				(( ++polyfill_replacement_succeeded_count ))
			fi
		done
	done {fd_num}< "$providedextensionslog_file_path" # use bash 4.1+ automatic file descriptor allocation (better than hardcoding e.g. "3<"), otherwise this loop's stdin (the lines of the file) will be consumed by programs called inside the loop
	exec {fd_num}>&-
	build_report::stop_timer platform.install.polyfill_replacement
	# the number of native packages we tried to install because a polyfill initially caused them to get skipped
	build_report::set_raw platform.install.polyfill_replacement.packages.attempted_count "$polyfill_replacement_attempted_count"
	# the number of successful native installs - this can also mean an ext was already enabled in PHP, or only had to be enabled
	build_report::set_raw platform.install.polyfill_replacement.packages.succeeded_count "$polyfill_replacement_succeeded_count"
	if (( ${#polyfill_replacement_unavailable[@]} )); then
		# the list of unsuccessful native installs (because package not available or conflicting)
		# sort names into a new array (sort -z and mapfile -d '' for NUL byte separator handling)
		mapfile -td '' polyfill_replacement_unavailable_sorted < <(printf '%s\0' "${polyfill_replacement_unavailable[@]}" | sort -z)
		# log names as comma-separated list (the "*" array expansion uses the first character from IFS, which is what we want)
		build_report::set_string platform.install.polyfill_replacement.packages.unavailable "$(IFS=,; echo "${polyfill_replacement_unavailable_sorted[*]}")"
	fi
	# the number of actual packages we installed - "real" download/installs, possibly in turn with dependencies to pull in first
	# back up the count of installed packages from the previous step
	platform_packages_installed_count_previous=$platform_packages_installed_count
	# set the new grand total (will be logged again further down) to what we have now
	# if there are no packages, 'composer show -f json' returns an empty array instead of an object with empty "installed" key
	platform_packages_installed_count=$(platform-composer show -f json "heroku-sys/*" | jq -r '.installed? // {} | length' || printf -- "-1")
	# log the difference between the two as the count for this step
	build_report::set_raw platform.install.polyfill_replacement.packages.installed_count "$(( platform_packages_installed_count - platform_packages_installed_count_previous ))"
fi
# the number of polyfill packages we saw (i.e. packages declaring they are filling in for one or more e.g. extensions)
# we want this always logged, so it is outside the if above
build_report::set_raw platform.polyfill_count "$polyfill_count"

# clean up installer variables and files
rm -f "$providedextensionslog_file_path"
unset providedextensionslog_file_path
# We must close this file descriptor, or any spawned child processes may inherit it.
# If such a child process daemonizes itself (e.g. as ScoutAPM's core-agent does during Laravel framework startup in a post-install-cmd hook), either this bash process, or PID 1, will then wait forever for that FD to be closed, which the child process will not do because it is not aware of the inherited FD.
exec {PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO}>&-
unset PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO

# log total number of installed platform packages (user deps, polyfill replacements, composer, web servers)
# this variable may have been updated by the polyfill replacement step
build_report::set_raw platform.packages.installed_count "$platform_packages_installed_count"

# export our "do not auto.start APM extensions" magic INI directory to PHP_INI_SCAN_DIR for ourself and for later buildpacks (but not for runtime)
# but first, there might be a user-supplied scan dir we have to take into account, so load that config var
export_env_dir "$env_dir" '^PHP_INI_SCAN_DIR$'
echo "export PHP_INI_SCAN_DIR=\${PHP_INI_SCAN_DIR-}:$bp_dir/conf/php/apm-nostart-overrides/" >> $bp_dir/export
# later when we load all other user config vars, we need to ignore this one, or our apm-nostart-overrides addition would get re-set
ignore_config_vars+=("PHP_INI_SCAN_DIR")
# env var based disabling for e.g. ScoutAPM (which would otherwise download and start its core-agent)
# we have to do three things here:
# 1. remember the names of the variables so we can prevent them from getting set by export_env_dir later
# 2. export each variable into the current scope
# 3. put export statements for each into $bp_dir/export
# Number 1 we do in a subshell, by sourcing the file and comparing (via comm) the list of exported variable names, appending additions to the list of config vars we have to ignore later
# (process substitution instead of pipe into readarray (subhell!); -t removes trailing newlines; -O sets start of array index to write to, since we want to append to the array; sort variable names to ensure comm does not complain about Bash outputting all uppercase variables before all lowercase variables)
readarray -t -O ${#ignore_config_vars[@]} ignore_config_vars < <(vars=$(compgen -e | sort -f); source "$bp_dir/conf/php/apm-nostart-overrides/export"; comm -3 <(echo "$vars") <(compgen -e | sort -f) | cut -f2)
# Numbers 2 and 3 are easy (same as above for PHP_INI_SCAN_DIR, we append to $bp_dir/export, plus we source it later anyway)
cat "$bp_dir/conf/php/apm-nostart-overrides/export" >> $bp_dir/export

# earlier we wrote at least one $PATH entry that we'll need now (and just above we added PHP_INI_SCAN_DIR etc exports), and installed packages will likely have added to it too
source $bp_dir/export

# from here onwards we're using the composer we installed via platform install with the PHP runtime that we installed via platform install

# log runtime version and series
php_version=($(php -r 'printf("%s\n%d.%d", PHP_VERSION, PHP_MAJOR_VERSION, PHP_MINOR_VERSION);'))
build_report::set_string platform.php.version "${php_version[0]}"
build_report::set_string platform.php.series "${php_version[1]}"

build_report::stop_timer platform.install

if eoldate=$(php $bp_dir/bin/util/eol.php); then
	:
else
	code=$?
	eolmsg=$(
		cat <<-EOF
			It is strongly recommended you update your app to a version of
			PHP with "active support" status immediately to ensure you get
			the latest bugfixes and security updates each time you deploy.
			
			You may check the list of versions supported by the PHP Group
			and their EOL dates here: http://php.net/supported-versions.php
			
			For a list of supported runtimes & extensions on Heroku, please
			refer to: https://devcenter.heroku.com/articles/php-support
		EOF
	)
	if (( $code == 2 )); then
		mcount "warnings.runtime_eol.eol_reached"
		warning <<-EOF
			Your selected PHP version has reached end-of-life
			
			No updates or security fixes have been provided for your PHP
			version series by the PHP Group since $eoldate.
			
			$eolmsg
		EOF
	elif (( $code == 3 )); then
		mcount "warnings.runtime_eol.eol_close"
		warning <<-EOF
			Your selected PHP version is close to end-of-life
			
			No updates or security fixes will be provided for your PHP
			version series by the PHP Group as of $eoldate.
			
			$eolmsg
		EOF
	elif (( $code == 4 )); then
		mcount "warnings.runtime_eol.eom_reached"
		warning <<-EOF
			Your app's PHP version is no longer actively maintained
			
			Only security updates will be provided for your PHP version
			series by the PHP Group until its end-of-life on $eoldate.
			
			$eolmsg
		EOF
	elif (( $code == 5 )); then
		mcount "warnings.runtime_eol.eom_close"
		warning <<-EOF
			Your app's PHP version is close to end of maintenance
			
			Only security updates will be provided for your PHP version
			series by the PHP Group as of $eoldate.
			
			$eolmsg
		EOF
	fi
fi

build_report::start_timer dependencies.install

status "Installing dependencies..."

composer_vendordir=$(composer config --no-plugins vendor-dir 2> /dev/null)
composer_bindir=$(composer config --no-plugins bin-dir 2> /dev/null)

# throw a notice if people have added their vendor dir to Git; that's bad practice and makes everything slow and cluttered
if [[ -f "$composer_vendordir/autoload.php" && -d "$composer_vendordir/composer" ]]; then
	# we should not do this check separately; there is no reliable way of telling whether or not it really is the real Composer bin dir or if it comes from somewhere else
	mcount "warnings.vendor_dir"
	warning <<-EOF
		Composer vendor dir found in project!
		
		Your Git repository contains Composer's '$composer_vendordir' directory.
		
		This directory should not be under version control; only your
		'$COMPOSER' and '$COMPOSER_LOCK' files need to be added, as
		Composer will handle installation of dependencies on deploy.
		
		To suppress this notice, first remove the folder from the index
		by running 'git rm -r --cached $composer_vendordir/'.
		Next, edit your project's '.gitignore' file and add the folder
		'/$composer_vendordir/' to the list, then commit the changes.
		$(
			[[ ! "$composer_bindir/" == "$composer_vendordir"/* && -d "$composer_bindir" ]] && cat <<-EOF2
			
				Your Composer bin dir is configured to reside outside of vendor
				dir, so please repeat the two steps above for '$composer_bindir/'.
			
			EOF2
		)
		For more info, refer to the Composer FAQ: http://bit.ly/1rlCSZU
	EOF
fi

# handle custom oauth keys
export_env_dir "$env_dir" '^COMPOSER_GITHUB_OAUTH_TOKEN$'
COMPOSER_GITHUB_OAUTH_TOKEN=${COMPOSER_GITHUB_OAUTH_TOKEN:-}
if [[ -n "$COMPOSER_GITHUB_OAUTH_TOKEN" ]]; then
	if curl --fail --silent -H "Authorization: token $COMPOSER_GITHUB_OAUTH_TOKEN" https://api.github.com/rate_limit > /dev/null; then
		composer config --no-plugins -g github-oauth.github.com "$COMPOSER_GITHUB_OAUTH_TOKEN" &> /dev/null # redirect outdated version warnings (Composer sends those to STDOUT instead of STDERR)
		notice_inline 'Using $COMPOSER_GITHUB_OAUTH_TOKEN for GitHub OAuth.'
	else
		build_report::set_string failure_reason composer.config.auth.COMPOSER_GITHUB_OAUTH_TOKEN.missing
		error <<-EOF
			Invalid token for GitHub OAuth!
			
			The OAuth token set in the '\$COMPOSER_GITHUB_OAUTH_TOKEN'
			config var is invalid. Please ensure that you obtain a valid
			token from https://github.com/settings/tokens and set it on the
			app using 'heroku config:set COMPOSER_GITHUB_OAUTH_TOKEN=...'.
		EOF
	fi
else
	# don't forget to remove any stored key if it's gone from the env
	composer config --no-plugins -g --unset github-oauth.github.com &> /dev/null # redirect outdated version warnings (Composer sends those to STDOUT instead of STDERR)
fi
# no need for the token to stay around in the env
unset COMPOSER_GITHUB_OAUTH_TOKEN
ignore_config_vars+=("COMPOSER_GITHUB_OAUTH_TOKEN")

# turn ignore_config_vars into a pipe-separated list, for easy insertion into the regex
ignore_config_vars=$(IFS="|"; echo -n "${ignore_config_vars[*]}")
# export config vars, except those we do not want to clobber our environment
export_env_dir "$env_dir" '^[A-Z_][A-Z0-9_]*$' "^(${ignore_config_vars})$"
# install dependencies unless composer.json is completely empty (in which case it'd talk to packagist.org which may be slow and is unnecessary)
if cat "$COMPOSER" | python3 -c 'import sys,json; sys.exit(not json.load(sys.stdin));'; then
	install_log=$(mktemp -t heroku-buildpack-php-composer-install-log-XXXX)
	composer install ${HEROKU_PHP_INSTALL_DEV-"--no-dev"} --prefer-dist --optimize-autoloader --no-progress --no-interaction 2>&1 | tee "$install_log" | indent || {
		code=$?
		if [[ $code -eq 2 ]]; then
			# dependency solving failed, which should only ever happen if people have platform overrides in their config
			mcount "failures.dependencies.solving.$(detect_dependencies_solving_failures < "$install_log")"
			build_report::set_string failure_reason dependencies.install.solving
			build_report::set_string failure_detail "$(head -c 1000 "$install_log")"
		else
			mcount "failures.dependencies.install.$(detect_dependencies_install_failures < "$install_log")"
			build_report::set_string failure_reason dependencies.install.install
			build_report::set_string failure_detail "$(head -c 1000 "$install_log")"
		fi
		# FIXME: can we provide more advice depending on the error?
		error <<-EOF
			Dependency installation failed!
			
			The 'composer install' process failed with an error. The cause
			may be the download or installation of packages, or a pre- or
			post-install hook (e.g. a 'post-install-cmd' item in 'scripts')
			in your '$COMPOSER'.
			
			Typical error cases are out-of-date or missing parts of code,
			timeouts when making external connections, or memory limits.
			
			Check the above error output closely to determine the cause of
			the problem, ensure the code you're pushing is functioning
			properly, and that all local changes are committed correctly.
			
			For more information on builds for PHP on Heroku, refer to
			https://devcenter.heroku.com/articles/php-support
		EOF
	}
fi

# only perform the check for buildpack package if we're not running in Heroku CI
if [[ -z "${HEROKU_PHP_INSTALL_DEV+are-we-running-in-ci}" ]]; then
	composer show --quiet heroku/heroku-buildpack-php 2>/dev/null && {
		build_report::set_string failure_reason dependencies.install.buildpack_as_dependency
		error <<-EOF
			Package 'heroku/heroku-buildpack-php' found!
			
			Your '$COMPOSER' requires 'heroku/heroku-buildpack-php' in
			the 'require' section. This package may only be used as a
			dependency in 'require-dev', because Heroku installs the latest
			version of the buildpack during builds.
			
			Please perform the following steps locally on your computer to
			resolve this issue before attempting another deploy:
			1) move the requirement for 'heroku/heroku-buildpack-php' from
			   section 'require' to 'require-dev' in '$COMPOSER'
			2) run 'composer update' to re-generate the lock file
			3) stage changes using 'git add $COMPOSER $COMPOSER_LOCK'
			4) commit changes using 'git commit'
		EOF
	}
fi

build_report::stop_timer dependencies.install

# log number of installed dependencies
# if there are no packages, 'composer show -f json' returns an empty array instead of an object with empty "installed" key
build_report::set_raw dependencies.packages.installed_count "$(composer show --no-plugins -f json | jq -r '.installed? // {} | length' || printf -- "-1")"

if cat "$COMPOSER" | python3 -c 'import sys,json; sys.exit("compile" not in json.load(sys.stdin).get("scripts", {}));'; then
	build_report::start_timer scripts.compile
	
	status "Running 'composer compile'..."
	composer run-script ${HEROKU_PHP_INSTALL_DEV-"--no-dev"} --no-interaction compile 2>&1 | indent || {
		build_report::set_string failure_reason scripts.compile
		error <<-EOF
			Compile step failed!
			
			Installation of dependencies was successful, but the custom
			script you're using to perform actions after 'composer install'
			failed with the error above.
			
			Check that the 'compile' command(s) in the 'scripts' section of
			your '$COMPOSER' are working properly and not running into
			timeouts or memory limits.
			
			For more information on the 'composer compile' step, refer to
			https://devcenter.heroku.com/articles/php-support
		EOF
	}
	
	build_report::stop_timer scripts.compile
fi

status "Preparing runtime environment..."

# install this buildpack like a composer package
# it will contain the apache/nginx/php configs and the boot script
# TODO: warn if require-dev has the package using a different branch
shopt -u dotglob # we don't want .git, .gitignore et al
# figure out the package dir name to write to and copy to it
hbpdir="$composer_vendordir/$(cat $bp_dir/composer.json | python3 -c 'import sys, json; print(json.load(sys.stdin)["name"])')"
mkdir -p "$build_dir/$hbpdir"
cp -r "$bp_dir"/* "$build_dir/$hbpdir/"
# make bin dir, just in case
mkdir -p "$build_dir/$composer_bindir"
# figure out shortest relative path from vendor/heroku/heroku-buildpack-php to vendor/bin (or whatever the bin dir is)
relbin=$(python3 -c "import os.path; print(os.path.relpath('$hbpdir', '$composer_bindir'))")
# collect bin names from composer.json
relbins=$(cat $bp_dir/composer.json | python3 -c 'import sys, json; { print(sys.argv[1]+"/"+bin) for bin in json.load(sys.stdin)["bin"] }' $relbin)
# link to bins
cd $build_dir/$composer_bindir
ln -fs $relbins .
cd $build_dir

if [[ ! -f "Procfile" ]]; then
	echo "web: heroku-php-apache2" > Procfile
	notice_inline "No Procfile, using 'web: heroku-php-apache2'."
fi

# write empty WEB_CONCURRENCY.sh to overwrite the defaults logic from a prior buildpack, e.g. Node (all buildpacks use the same filename to allow this)
> $build_dir/.profile.d/WEB_CONCURRENCY.sh

# unless we're running a CI build...
if [[ "${HEROKU_PHP_INSTALL_DEV+CI}" != "CI" ]]; then
	build_report::start_timer apm.automagic
	
	# see if we want to auto-enable blackfire and newrelic extensions
	# we do this at the end because even with our apm ext "do not start" overrides via PHP_INI_SCAN_DIR,
	# there can still be startup messages that clobber output during userland composer install etc
	status "Checking for additional extensions to install..."
	# again make a FD for display output and export env var for the installer plugin
	exec {PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO}>&1
	export PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO
	# special treatment for Blackfire; we enable it if we detect a server id and a server token for it
	install_blackfire_ext
	# special treatment for New Relic; we enable it if we detect a license key for it
	install_newrelic_ext
	install_newrelic_userini
	# final FD cleanup so nothing after us can inherit it for any reason
	exec {PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO}>&-
	unset PHP_PLATFORM_INSTALLER_DISPLAY_OUTPUT_FDNO
	
	build_report::stop_timer apm.automagic
fi

# clean up our bootstrapped PHP and Composer
rm -rf /app/.heroku/php-min $build_dir/.heroku/php-min

build_report::stop_timer __main__
